"""


usage: render_docs <usage-json> [<descriptions-yaml>]
"""
import json
import html

import docopt
import yaml

template = """\
# Zwift Workout File Reference

This page describes the XML elements (tags) and attributes that can be used in
[Zwift workout files][zwift-support-workouts]. It's automatically generated by
analysing all of the workouts included with Zwift.

It's intended to help people creating workouts by directly by writing XML, or
people writing software to generate Zwift workouts.

Some of the elements and attributes don't have any effect, even though they
appear in the built-in workouts. The [Quantize](#attribute-quantize) attribute
is such an example.

[zwift-support-workouts]: https://support.zwift.com/en/-sharing-importing-custom-workouts-\(.zwo-files\)-\(cycling\)-r1IlCybrQ

This is a work in progress. If you know about Zwift workouts, you can help by
[contributing to this guide](./README.md#contributing).

## Structure Index

{index_tree}

## Elements

{elements}

## Attributes

{attributes}\
"""


def indexed_by_path(elements):
    index = {}

    for el in elements:
        for path in el['paths']:
            key = tuple(path)
            path_els = index.setdefault(key, {})
            path_els.setdefault(el['tag'], el)
    return index


def own_path(el):
    return el['']


def index_tree(usages):
    by_path = indexed_by_path(usages)

    def _els_under(path):
        return [
            {**el, 'children': _els_under(path + (el['tag'],))}
            for el in by_path.get(path, {}).values()
        ]

    root, = _els_under(())
    return root


def sort_key_el_tag(el):
    return sort_key_no_case(el['tag'])


def sort_key_attribute_name(att):
    return sort_key_no_case(att['attribute'])


def sort_key_no_case(val):
    if isinstance(val, tuple):
        return 0, None, None
    return 1, val.lower(), val


def render_linked_tag(tag, attributes_html=None):
    if tag == ():
        # Document root elements
        return '<em>[none (top-level element)]</em>'

    rendered_attributes = ' ' + attributes_html if attributes_html else ''
    return f'&lt;<a href="#element-{html.escape(tag)}"><strong><code>{html.escape(tag)}</code></strong>{rendered_attributes}</a>&gt;'


def render_linked_tags(tags):
    return ' '.join(render_linked_tag(tag)
                    for tag in sorted(tags, key=sort_key_no_case))


def render_linked_attribute(attr):
    return f'<a href="#attribute-{html.escape(attr)}"><code>{html.escape(attr)}</code></a>'


def render_linked_attributes(attrs):
    return ' '.join(render_linked_attribute(a)
                    for a in sorted(attrs, key=sort_key_no_case))


def render_index_el_tree(tree):
    def _render(el, depth):
        indent = " " * depth * 2
        attributes = render_linked_attributes(el['attributes'])
        tag = render_linked_tag(el['tag'], attributes)

        yield f'{indent}- {tag}'

        for child in sorted(el['children'], key=sort_key_el_tag):
            yield from _render(child, depth + 1)

    return '\n'.join(_render(tree, 0))


_DEFAULT_ELEMENT_DESC = '*Not yet described.*'
_EMPTY_CELL = '\u2015'


def get_child_elements(el, els_by_path):
    own_paths = [tuple(path) + (el['tag'],) for path in el['paths']]
    return set(child_el['tag']
               for path in own_paths
               for child_el in els_by_path.get(path, {}).values())


def get_parent_elements(el):
    return set(path[-1] if path else () for path in el['paths'])


def render_value_freq(value, freq):
    return f'<td>{freq * 100:.2f}%</td><td><code>{html.escape(value)}</code></td>'


def render_value_description(value_desc):
    if value_desc is None:
        return (f'<tr><td><strong>Inner value</strong></td>'
                f'<td>{html.escape(_EMPTY_CELL)}</td></tr>')

    is_exhaustive = value_desc['value_samples']['exhaustive']
    total_occurrences = value_desc['value_samples']['total_occurrences']
    values = value_desc['value_samples']['values']

    rendered_values = '\n'.join(
        (f'<tr>'
         f'    <td rowspan="{len(values)}">{"Values seen" if is_exhaustive else "Top values seen"}</td>'
         f'    {render_value_freq(val, freq)}'
         f'</tr>'
         if i == 0 else
         f'<tr>{render_value_freq(val, freq)}</tr>')
        for i, (val, freq) in enumerate(values))

    return f'''\
<tr>
    <td rowspan="{len(values) + 2}"><strong>Inner value</strong></td>
    <td>Data type</td>
    <td colspan="2">{html.escape(value_desc['datatype'])}</td>
</tr>
<tr>
    <td>Times seen</td>
    <td colspan="2">{html.escape(str(total_occurrences))}</td>
</tr>
{rendered_values}\
'''


def combine_text_sections(*sections):
    def combine(secs):
        for s in secs:
            if s is None:
                continue
            if isinstance(s, str):
                yield s
            else:
                yield from combine(s)
    return '\n\n'.join(combine(sections))


def indent_lines(text, *, indent):
    return '\n'.join(f'{indent}{l}' for l in text.split('\n'))


def render_code_snippet(example):
    if 'interval_code' in example:
        code = f'''\
<workout_file>
  <!-- [...] -->
  <workout>
{indent_lines(example['interval_code'].strip(), indent='    ')}
  </workout>
</workout_file>
'''
    else:
        code = example['code']

    return f'''\
```xml
{code}\
````
'''


def render_example(example, default_title='Example'):
    if isinstance(example, str):
        example = {'code': example}

    title = example.get('title') or default_title
    description = example.get('description', '').strip() or None
    code = render_code_snippet(example)

    return combine_text_sections(
        f'##### {title}',
        description,
        code
    )


def render_examples(examples):
    if not examples:
        return

    if not isinstance(examples, list):
        examples = [examples]

    return combine_text_sections(
        '#### Usage examples',
        [render_example(e, default_title=f'Example {i}')
         for i, e in enumerate(examples, 1)]
    )


def trim_leading_line_ws(text):
    return '\n'.join(line.lstrip() for line in text.split('\n'))


def render_element(el, els_by_path, desc_data):
    desc_data = desc_data or {}
    description = desc_data.get('description', _DEFAULT_ELEMENT_DESC)
    examples = render_examples(desc_data.get('examples')) or ''
    inner_value = render_value_description(el['value'])
    inner_elements = render_linked_tags(get_child_elements(el, els_by_path))
    contained_by = render_linked_tags(get_parent_elements(el))
    attributes = render_linked_attributes(el['attributes'])

    table = f'''\
<table>
    <tr>
        <td><strong>Attributes</strong></td>
        <td colspan="3">{attributes or _EMPTY_CELL}</td>
    </tr>
    <tr>
        <td><strong>Inner elements</strong></td>
        <td colspan="3">{inner_elements or _EMPTY_CELL}</td>
    </tr>
    <tr>
        <td><strong>Contained by</strong></td>
        <td colspan="3">{contained_by or _EMPTY_CELL}</td>
    </tr>
    {inner_value}
</table>\
'''

    return f'''\
### Element **`<{el['tag']}>`**

{description}

{trim_leading_line_ws(table)}

{examples}
'''.rstrip()


def render_attribute(att, desc_data):
    desc_data = desc_data or {}
    description = desc_data.get('description', _DEFAULT_ELEMENT_DESC)
    inner_value = render_value_description(att['value'])
    host_tags = render_linked_tags(att['tags'])

    table = f'''\
<table>
    <tr>
        <td><strong>Occurs on</strong></td>
        <td colspan="3">{host_tags or _EMPTY_CELL}</td>
    </tr>
    {inner_value}
</table>\
'''
# ### Attribute **`{att['attribute']}`**`="..."`
# ### Attribute <code><strong>{att['attribute']}</strong>="…"</code>
    return f'''\

### Attribute `{att['attribute']}="…"`

{description}

{trim_leading_line_ws(table)}\
'''


def render_elements(elements, desc_data=None):
    desc_data = desc_data or {}
    els_by_path = indexed_by_path(elements)

    rendered_elements = (render_element(el, els_by_path,
                                        desc_data.get(el['tag']))
                         for el in sorted(elements, key=sort_key_el_tag))

    return '\n\n'.join(rendered_elements)


def render_attributes(attributes, desc_data=None):
    desc_data = desc_data or {}

    rendered_attributes = (
        render_attribute(att, desc_data.get(att['attribute']))
        for att in sorted(attributes, key=sort_key_attribute_name))

    return '\n\n'.join(rendered_attributes)


def main():
    args = docopt.docopt(__doc__)

    with open(args['<usage-json>'], encoding='utf-8') as f:
        usage_stats = json.load(f)

    if args['<descriptions-yaml>']:
        with open(args['<descriptions-yaml>'], encoding='utf-8') as f:
            desc_data  = yaml.safe_load(f)
            if not isinstance(desc_data, dict):
                raise TypeError('<descriptions-yaml> did not contain a hash at '
                                'the top level')
    else:
        desc_data = {}

    elements = usage_stats['elements']
    attributes = usage_stats['attributes']
    print(template.format(
        index_tree=render_index_el_tree(index_tree(elements)),
        elements=render_elements(elements, desc_data.get('elements')),
        attributes=render_attributes(attributes, desc_data.get('attributes'))
    ))


if __name__ == '__main__':
    main()
